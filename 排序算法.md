《11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？》笔记：
#### 如何分析一个排序算法
* 排序算法的执行效率
	* 最好情况、最坏情况、平均情况时间复杂度 and 最好、最坏、平均情况下的时间复杂度对应的原始数据是什么样子的
	* 时间复杂度的系数、常数、低阶（通常排序的规模不很大）

	时间复杂度是数据规模N较大的时候的增长趋势。
	
	* 比较次数（交换次数）

* 排序算法的内存消耗

	原地排序：空间复杂度为O(1)的排序算法

* 排序算法的稳定性

	* 什么是稳定性？
	
	  稳定性指的是在排序过程中元素的前后位置没有发生变化。
	
	* 稳定性到底有什么影响呢？

	  举个例子：现在我们要给电商交易系统中的”订单“排序。订单的两个属性：下单时间和下单金额。我们现在又10万条数据，要求按照金额从大到小进行排序，金额相同的按照下单时间排序。
		* 先按照订单的金额从大到小排序，再将金额相同的订单按照时间的先后排序（麻烦）
		* 将所有订单按照时间的先后进行排序，再利用==稳定排序算法==队所有的数据降序排序

#### 冒泡排序算法
* 思想：每次冒泡操作都会队相邻的两个元素进行比较，看是否满足大小关系的要求，如果不满足就让他们两个互换，一次冒泡会让至少一个元素移动到他该在的位置
* 实现

```java

// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```
* 算法分析

	* 内存消耗： 排第排序O(1)
	* 稳定性：稳定
	* 执行效率：

		* 比较次数：n*(n-1)/2
		* 交换次数：逆序度，也就是n*(n-1)/2–初始有序度

		最好情况下（已经排好序）只进行一次冒泡，没有交换的情况下，O(1);
		
		最坏情况下（逆序）n次冒泡，O(n^2);
		
		平均情况下 O(n^2)		
		
#### 插入排序算法

* 思想：分为已排序区间和未排序区间，将未排序区间的元素插入到已排序的区间中
* 算法分析：
	* 稳定性：稳定
	* 内存消耗：原地排序
	* 执行效率：
		* 比较：O(n^2)
		* 移动：逆序度
		* 平均时间复杂度：O(n2) 最好O(n) 最坏O(n^2)
* 实现：

```java

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

#### 选择排序算法
* 思路：从后面的数中选择出数字最小的，与前面的元素交换
* 不稳定+最好|最坏|平均O(n^2)+原地排序
* 实现：

```python
# 选择排序
def select(nums):
    l = len(nums)
    for i in range(l-1):
        value = i
        for j in range(i+1,l):
            if nums[j] < nums[value]:
                value = j
        if i!=value:
            nums[i], nums[value] = nums[value], nums[i]
    print(nums)
```
#### 解答开篇：为什么插入排序比冒泡排序更受欢迎？

他们的时间复杂度和空间复杂度均相同，交换次数也都是逆序数，从代码上考虑：

```java

// 冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

//插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```
冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个

![](/Users/yanglan/git_rep/pic/排序1.jpg)

#### 归并排序
* 思路：分治思想，将一个大问题分解成小的子问题求解。

![](/Users/yanglan/git_rep/pic/归并排序分解图.jpg)
* 为代码：

```java

// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
```
* 性能分析：

	* 稳定排序
	* 时间复杂度最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
	* 空间复杂度是 O(n)

	
#### 快速排序
* 思想：

	如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。
	![](/Users/yanglan/git_rep/pic/快排.jpg)
	
* 时间复杂度： 平均和最坏 O(nlogn)

	最坏O(n2)
* 空间复杂度：原地排序
* 代码：

```java
private static void quickSort(int[] a, int head, int tail) {

        int low = head;
        int high = tail;
        int pivot = a[low];
        if (low < high) {

            while (low<high) {
                while (low < high && pivot <= a[high]) high--;
                a[low] = a[high];
                while (low < high && pivot >= a[low]) low++;
                a[high]=a[low];
            }
            a[low] = pivot;

            if(low>head+1) quickSort(a,head,low-1);
            if(high<tail-1) quickSort(a,high+1,tail);
        }

    }

```
#### 解答开篇：寻找无序数组中的第K大的元素

快排思想:

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        kth = len(nums)-k
        if len(nums) == 0 or nums is None:
            return 
        num = self.quicksort(nums, 0, len(nums)-1, kth)
        return num
    
    def quicksort(self, nums, p, q, kth):
        head = p
        tail = q
        povit = nums[head]
        while head<tail:
            while head<tail and nums[tail]>povit:
                tail -= 1
            nums[head] = nums[tail]
            while head<tail and nums[head]<=povit:
                head += 1
            nums[tail] = nums[head]
           
           
        nums[head] = povit
        if head == kth:
            return povit
        elif head > kth:
            return self.quicksort(nums, p, head-1, kth)
        
        else:
            return self.quicksort(nums, head+1, q, kth)
```

《13 | 线性排序：如何根据年龄给100万用户数据排序？》笔记

#### 1、线性排序
桶排序、计数排序、基数排序

非基于比较的排序算法，不涉及到元素之间的比较操作

对排序的数据要求比较苛刻，掌握这些算法的应用场景

抛出问题：如何给100万用户排序

#### 桶排序

<li>思想：</li>
先将数据分到几个==有序==桶里，每个桶的数据再单独排序，桶内完成排序，再把数据依次取出，组成的序列就是有序的了。

<li>时间复杂度：</li>

设排序的数据有n个，我们把他们均匀的划分到m个桶内，每个桶里就有n/m个元素，每个桶内的元素利用快速排序，时间复杂度为 O(n*log(n/m))，当桶的个数m接近数据个数n时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

<li>局限：</li>

1. 要求排序的数据很容易的划分成m个桶，并且，桶和桶之间有着天然的大小顺序，这样每个桶内的数据排完后，桶和桶之间的数据就不需要再排序了
2. 数据在各个桶之间的分布是均匀的。
3. 桶排序比较适合外部排序。外部排序指的是数据存储在外部的磁盘中，数据量大，内存有限，无法将数据全部加载到内存。

* 我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？
	
	先扫描一下文件，查看订单金额所处的范围。将所有订单金额划分到100个桶里面，第一个桶划分存放金额1-1000元...以此类推，将订单分类，如果有的桶中的数据过大，再划分成范围更小的几个桶，直到所有的文件都能读入内存为止。
	
#### 2、计数排序

* 思想：计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，每个桶内的数据值都是相同的，省掉了桶内排序的时间。
* 过程解读：

![](/Users/yanglan/git_rep/pic/计数排序.jpg)
* 代码：

```java

// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```
* 局限：计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。


#### 3、基数排序
* 算法原理（以排序10万个手机号为例来说明）
	1. 比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。
	2. 借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
	3. 经过11次排序后，手机号码就变为有序的了。
	4. 每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。
	
* 使用条件
	1. 要求数据可以分割独立的“位”来比较；
	2. 位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；
	3. 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。


#### 思考
如何根据年龄给100万用户数据排序？

答：桶排序

#### 排序算法比较：
![](/Users/yanglan/git_rep/pic/排序算法总结.jpg)
