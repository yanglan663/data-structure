《05 | 数组：为什么很多编程语言中数组都从0开始编号？》
笔记：

# 数组如何实现随机访问

## 什么是数组？

数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储相同类型的数据。

## 什么是线性表（Linear List）？

线性表就是数据排成一条线一样的结构，每个线性表的数据最多只有前后两个方向。

例如：数组，链表，队列，栈 等都是线性表结构

## 什么是非线性表？

例如：二叉树，堆，图，等，是非线性表，是因为，在非线性表中，数据之间并不是简单的前后关系

## 连续内存+相同数据类型=随机访问

例如：`int[] a = new int[10]` 

1，计算机给数组a[10]，分配了一组连续的内存空间 

2，比如内存块的首地址为 `base_address = 1000` 

3，当计算给每个内存单元分配一个地址，计算机通过地址来访问数据。当计算机需要访问数组的某个元素的时候，会通过一个**寻址公式**来计算存储的内存地址。

公式如下：

```java
a[i]_address = base_address + i * data_type_size
```
arr[i] 首地址 = 数组内存块首地址 + 数据类型大小 * i ，其中i为偏移量。

**base_address**：内存块的首地址 

**data_ type_size**：数组中每个元素的大小，如元素大小是4个字节。


## 低效的“插入”和“删除”

* **插入**：从最好O(1) | 最坏O(n) | 平均 n(n+1)/2 近似为 O(n)

**什么时候会是O(1)？**

数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。

例如：a[10] 数组存储了5个元素： `A B C D E`

我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。

最后，数组中的元素如下： `A，C，X，D，E，C`。

**什么时候会是最坏O(n)？**

从数组开头插入数据，所有的数据往后移一位，情况最差，时间复杂度为O(n) ； 
每一位插入的概率一样，所以平均时间复杂度为(1+2+...+n)/n = (1+n)/2 = O(n)

* **删除**：从最好O(1) 最坏O(n) 平均O(n) 

和插入数据类似，如果我们要删除 K 个位置的数据，我了内存的连续性，我们需要搬移 K 位置后的所有数据往前移动一位，不然的话内存就不连续了

**什么时候会是O(1)？**

删除开头的数据

**什么时候会是最坏O(n)？**

同数组插入的原理类似


* **标记-整理垃圾回收算法**。

在垃圾收集时此算法分为“标记”、“清除”两个阶段，先标记出需要回收的对象，再统一清除标记的对象。清除之后会产生大量不连续的内存碎片。
在标记完成之后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

## 用数组还是容器？ 

数组先指定容器大小，容器ArrayList可以动态扩容，并且封装了好多方法，一旦超过存储容量，扩容时比较耗时，因为涉及 内存申请和数据复制搬移到扩容后的数组。

1，如果已知数据大小，且涉及的数据操作比较简单，可以用数组。
2，比如已知 1 万条数据要存入 ArrayList，我们就可以事先指定容器大小，就可以，省掉多次的，内存申请，和数据搬移操作

3，容器无法存储基本类型，比如 int long 需要转换成包装类型，类型的转换有性能消耗
4，业务开发，使用容器足够，追求性能，首先用数组

**为什么数组要从 0 开始编号，而不是1？**

从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i<3;i++) 而不是for(int i = 0 ;i<=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。 


***


《06 | 链表（上）：如何实现LRU缓存淘汰算法?》
笔记：

### 一、什么是链表？
* 线性表 
* 从内存结构来看，内存空间不连续，用指针将一组零散的内存块串联起来，进行数据存储的数据结构。
* 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。

### 二、链表的特点
* 1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
* 2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

### 三、常用链表：单链表、循环链表和双向链表
  * 1.单链表
  
> 1）每个节点只包含一个指针，即后继指针。
> 
> 2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
> 
> 3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)

==单链表实现LRU淘汰缓存机制==
LRU的思想是优先淘汰最近最久未使用的数据，头节点代表最新使用的数据，尾节点表示最久未使用的数据，那么当一个数据到达的时候，先遍历链表看看是否有该数据；

如果没有，此时链表大小足够，插入数据到链表头部，链表已满删除最后的节点，插入到链表头部，

若有，删除该数据，再插入到链表头部。

`python
code
lRU
`

* 2.循环链表
> 1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。
> 
> 2）适用于存储有循环特点的数据，比如约瑟夫问题。

* 3.双向链表
> 1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
> 
> 2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。
> 
> 3）性能特点：
和单链表相比，存储相同的数据，需要消耗更多的存储空间。
插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。
对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
* 4.双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。
### 四、选择数组还是链表？
* 1.插入、删除和随机访问的时间复杂度
> 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
> 
> 链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。
* 2.数组缺点
> 1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
> 
> 2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
* 3.链表缺点
> 1）内存空间消耗更大，因为需要额外的空间存储指针信息。
> 
> 2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。
* 4.如何选择？
> 数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
如果代码对内存的使用非常苛刻，那数组就更适合。

课后习题：

判断链表是否是回文串

《07 | 链表（下）：如何轻松写出正确的链表代码？》笔记：
### 技巧一：理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。或者说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
### 技巧二：警惕指针丢失和内存泄漏
插入结点时，一定要注意操作的顺序

1.插入节点
在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：p—>next = x;x—>next = p—>next; 显然这会导致x节点的后继指针指向自身。
正确的写法是2句代码交换顺序，即：x—>next = p—>next; p—>next = x;

2.删除节点
在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：p—>next = p—>next—>next;
### 技巧三：利用哨兵简化实现难度
针对链表的插入和删除操作，需要对插入第一个节点和删除最后一个节点的情况作特殊处理

1.什么是“哨兵”？
链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。

2.未引入“哨兵”的情况
如果在p节点后插入一个节点，只需2行代码即可搞定：
new_node—>next = p—>next;
p—>next = new_node;
但，若向空链表中插入一个节点，则代码如下：
if(head == null){
head = new_node;
}
如果要删除节点p的后继节点，只需1行代码即可搞定：
p—>next = p—>next—>next;
但，若是删除链表的仅有的节点，则代码如下：
if(head—>next == null){
head = null;
}
从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

3.引入“哨兵”的情况
“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

4.“哨兵”还有哪些应用场景？
总结起来，哨兵最大的作用就是简化边界条件的处理。
### 技巧四：重点留意边界条件的处理
* 没有节点
* 只有一个节点
* 只有两个节点
* 看看头节点和尾节点是不是符合代码逻辑

### 技巧五：举例画图，辅助思考
### 技巧六：多学多练，没有捷径
* 1.单链表反转
* 2.链表中环的检测
* 3.两个有序链表合并
* 4.删除链表倒数第n个节点
* 5.求链表的中间节点
